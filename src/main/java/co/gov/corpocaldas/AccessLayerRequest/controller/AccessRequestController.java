package co.gov.corpocaldas.AccessLayerRequest.controller;

import co.gov.corpocaldas.AccessLayerRequest.dto.AccessRequestDto;
import co.gov.corpocaldas.AccessLayerRequest.dto.PaginatorDto;
import co.gov.corpocaldas.AccessLayerRequest.service.AccessRequestService;
import co.gov.corpocaldas.AccessLayerRequest.service.ValidateAccessService;
import io.swagger.annotations.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("${api.base.url}/access-request")
@Api
public class AccessRequestController {

    private final AccessRequestService accessRequestService;

    private final ValidateAccessService validateAccessService;

    public AccessRequestController(AccessRequestService accessRequestService, ValidateAccessService validateAccessService) {
        this.accessRequestService = accessRequestService;
        this.validateAccessService = validateAccessService;
    }

    /**
     * Endpoint that persist the information of an access request.
     * @param accessRequest Information of access request
     * @return Response entity with the status and body generated by request
     */
    @ApiOperation(value = "Endpoint that persist the information of an access request", response = AccessRequestDto.class)
    @ApiResponses(value = {
            @ApiResponse(code = 201, message = "The information of access request was persisted successfully"),
            @ApiResponse(code = 400, message = "The information of access request is invalid")
    })
    @PostMapping()
    public ResponseEntity<AccessRequestDto> saveRequestAccess(
            @ApiParam(value = "Information of access request", required = true) @RequestBody AccessRequestDto accessRequest) {
        return new ResponseEntity<>(accessRequestService.saveRequestAccess(accessRequest), HttpStatus.CREATED);
    }

    /**
     * Endpoint that update the information of a specific access request.
     * @param accessRequestId Identifier of the access request
     * @param accessRequest Updated information of the access request
     * @return Response entity with the updated information of the access request
     */
    @ApiOperation(value = "Endpoint that update the information of a specific access request", response = AccessRequestDto.class)
    @ApiResponses(value = {
            @ApiResponse(code = 202, message = "The information of the access request was updated successfully"),
            @ApiResponse(code = 400, message = "The identifier provided by path param mismatch with the identifier that" +
                    " is inside the information or the information of access request is invalid")
    })
    @PutMapping("/{accessRequestId}")
    public ResponseEntity<AccessRequestDto> updateRequestAccess(
            @RequestHeader(value = "authorization-token", required = false) String token,
            @RequestHeader(value = "authorization-user", required = false) Integer userId,
            @ApiParam(value = "Identifier of the access request", required = true) @PathVariable("accessRequestId") int accessRequestId,
            @ApiParam(value = "Updated information of the access request", required = true) @RequestBody AccessRequestDto accessRequest) {
        //validateAccessService.validateAccess(token, userId);
        return new ResponseEntity<>(accessRequestService.updateRequestAccess(accessRequestId, accessRequest), HttpStatus.ACCEPTED);
    }

    /**
     * Endpoint that returns the access request that are associated at layer with access granted equals to three
     * (private layer) and are waiting for approval.
     * @return List of access requests that waiting for approval
     */
    @ApiOperation(value = "Endpoint that returns the access request that are associated at layer with access granted" +
            " equals to three (private layer) and are waiting for approval", response = AccessRequestDto.class,
            responseContainer = "List<>")
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "The access requests that are waiting for approval was obtained successfully")
    })
    @GetMapping("/waiting-for-approval")
    public ResponseEntity<List<AccessRequestDto>> getRequestWaitingForApproval() {
        return new ResponseEntity<>(accessRequestService.requestWaitingForApproval(), HttpStatus.OK);
    }

    /**
     * Apply filter on access request by params selected.
     * @param name Name of the user that request the access
     * @param company Name of company or entity associated to request
     * @param email Email of the user that request the access
     * @param layername Layer name associated to request
     * @return Response entity with the access requests that matching with the parameters value
     */
    @ApiOperation(value = "Apply filter on access request by params selected", response = PaginatorDto.class)
    @ApiResponses(value = {
            @ApiResponse(code = 200, message = "The filter was applied on access request successfully")
    })
    @GetMapping()
    public ResponseEntity<PaginatorDto> filterAccessRequest(
            @RequestHeader(value = "authorization-token", required = false) String token,
            @RequestHeader(value = "authorization-user", required = false) Integer userId,
            @ApiParam(value = "Name of the user that request the access")
            @RequestParam(value = "name", required = false) String name,
            @ApiParam(value = "Name of company or entity associated to request")
            @RequestParam(value = "company", required = false) String company,
            @ApiParam(value = "Email of the user that request the access")
            @RequestParam(value = "email", required = false) String email,
            @ApiParam(value = "Layer name associated to request")
            @RequestParam(value = "layername", required = false) String layername,
            @ApiParam(value = "Layer access granted associated to request")
            @RequestParam(value = "access_granted", required = false) Integer layeraccessgranted,
            @ApiParam(value = "Determine if the access request has been approved or disapproved")
            @RequestParam(value = "approved", required = false) Boolean layerapproved,
            @ApiParam(value = "Page number", defaultValue = "0")
            @RequestParam(value = "page", defaultValue = "0") int page,
            @ApiParam(value = "Page size", defaultValue = "10")
            @RequestParam(value = "size", defaultValue = "10") int size) {
        //validateAccessService.validateAccess(token, userId);
        return new ResponseEntity<>(accessRequestService.filterAccessRequests(name, company, email, layername,
                layeraccessgranted, layerapproved, page, size), HttpStatus.OK);
    }

    /**
     * Endpoint that verify the access to private layer through token, email and layer identifier.
     * @param layerId Layer identifier
     * @param accessToken Access token provided by the platform
     * @param email Email of the user that requesting the token
     * @return Response entity with the result of verification
     */
    @ApiOperation(value = "Endpoint that verify the access to private layer through token, email and layer identifier",
        response = Boolean.class)
    @ApiResponses(value = {
            @ApiResponse(code = 202, message = "The verification was successful"),
            @ApiResponse(code = 401, message = "The data provided for verification is wrong")
    })
    @PostMapping("/validate-access")
    public ResponseEntity<AccessRequestDto> validateAccess(
            @ApiParam(value = "Layer identifier", required = true) @RequestParam("layerId") int layerId,
            @ApiParam(value = "Access token provided by the platform", required = true) @RequestParam("accessToken") String accessToken,
            @ApiParam(value = "Email of the user that requesting the token", required = true) @RequestParam("email") String email) {
        return new ResponseEntity<>(accessRequestService.validateAccess(layerId, email, accessToken), HttpStatus.ACCEPTED);
    }
}
